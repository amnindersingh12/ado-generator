<%# app/views/dashboard/_attendance_trend_chart_dual.html.erb %>
<div class="card shadow mb-4">
  <div class="card-header py-3 d-flex flex-row align-items-center justify-content-between bg-card-bg border-bottom-border">
    <h6 class="m-0 font-weight-bold text-primary">
      <i class="bi bi-graph-line me-2 text-accent"></i> <%= title %>
    </h6>
    <% if controls %>
      <div class="dropdown no-arrow">
        <a class="dropdown-toggle text-secondary" href="#" role="button" id="dropdownMenuLink" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
          <i class="bi bi-three-dots-vertical fa-sm fa-fw"></i>
        </a>
        <div class="dropdown-menu dropdown-menu-right shadow animated--fade-in" aria-labelledby="dropdownMenuLink">
          <div class="dropdown-header text-muted">More Actions:</div>
          <a class="dropdown-item" href="#">View Details</a>
          <a class="dropdown-item" href="#">Export Data</a>
        </div>
      </div>
    <% end %>
  </div>
  <div class="card-body bg-card-bg">
    <div class="chart-area">
      <canvas id="<%= chart_id %>"></canvas>
    </div>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    var ctx = document.getElementById('<%= chart_id %>').getContext('2d');

    // Dynamically fetch CSS variable values
    const getCssVar = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();

    // Chart.js specific color variables
    const bodyTextColor = getCssVar('--color-body-text');
    const secondaryColor = getCssVar('--color-secondary');
    const cardBorderColor = getCssVar('--color-card-border');

    // Get primary colors from props directly since they are already CSS vars
    const datasetInBorderColor = '<%= border_color_in %>';
    const datasetOutBorderColor = '<%= border_color_out %>';

    // Helper to generate rgba for fill colors if the base color is a CSS var
    // Requires your CSS variables like --color-primary-rgb to exist, or use a robust fallback
    const getRgbaFromCssVar = (cssVarName, alpha) => {
      const hexColor = getCssVar(cssVarName);
      if (!hexColor || hexColor.length < 7) { // Fallback if CSS var is not a valid hex
         console.warn(`CSS variable ${cssVarName} not found or invalid hex. Using default fallback for RGBA.`);
         return `rgba(0, 0, 0, ${alpha})`; // Default black with alpha
      }
      // Convert hex to rgb
      const r = parseInt(hexColor.slice(1, 3), 16);
      const g = parseInt(hexColor.slice(3, 5), 16);
      const b = parseInt(hexColor.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    };

    var myLineChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: <%= raw labels.to_json %>,
        datasets: [
          {
            label: '<%= dataset_in_label %>',
            data: <%= raw in_data.to_json %>,
            borderColor: datasetInBorderColor,
            backgroundColor: getRgbaFromCssVar(datasetInBorderColor, 0.1), // Light fill
            fill: true, // Enable fill below the line
            pointBackgroundColor: datasetInBorderColor,
            pointHoverBackgroundColor: datasetInBorderColor, // Often same as pointBackgroundColor for consistency
            pointRadius: 5,
            pointHoverRadius: 7,
            pointHitRadius: 50,
            pointBorderWidth: 2,
            tension: 0.3, // Smoother lines
          },
          {
            label: '<%= dataset_out_label %>',
            data: <%= raw out_data.to_json %>,
            borderColor: datasetOutBorderColor,
            backgroundColor: getRgbaFromCssVar(datasetOutBorderColor, 0.1), // Light fill
            fill: true, // Enable fill below the line
            pointBackgroundColor: datasetOutBorderColor,
            pointHoverBackgroundColor: datasetOutBorderColor,
            pointRadius: 5,
            pointHoverRadius: 7,
            pointHitRadius: 50,
            pointBorderWidth: 2,
            tension: 0.3, // Smoother lines
          },
        ],
      },
      options: {
        maintainAspectRatio: false,
        layout: { padding: { left: 10, right: 25, top: 25, bottom: 0 } },
        scales: {
          x: {
            grid: {
              display: false,
              drawBorder: false,
            },
            ticks: {
              maxTicksLimit: 7,
              color: bodyTextColor, // X-axis labels use theme text color
            },
          },
          y: {
            beginAtZero: true, // Start Y-axis at zero
            ticks: {
              maxTicksLimit: 5,
              padding: 10,
              color: bodyTextColor, // Y-axis labels use theme text color
              callback: function(value) { return '' + value; } // Format label if needed
            },
            grid: {
              color: cardBorderColor, // Grid lines use theme border color
              zeroLineColor: cardBorderColor,
              drawBorder: false,
              borderDash: [2],
              zeroLineBorderDash: [2],
            },
          },
        },
        plugins: {
          legend: {
            display: <%= controls.nil? ? true : controls %>, // Use the 'controls' prop for legend display
            position: 'bottom',
            labels: {
              color: bodyTextColor, // Legend text uses theme text color
            },
          },
          tooltip: {
            backgroundColor: getCssVar('--color-card-bg'), // Tooltip background from theme
            bodyColor: bodyTextColor, // Tooltip body text from theme
            titleColor: secondaryColor, // Tooltip title from theme
            borderColor: cardBorderColor, // Tooltip border from theme
            borderWidth: 1,
            xPadding: 15,
            yPadding: 15,
            displayColors: true,
            intersect: false,
            mode: 'index',
            caretPadding: 10,
          }
        },
      }
    });
  });
</script>